const _ = require('lodash');

const ShopifyService = require('../../services/shopifyIntegration');
const Springboard = require('../../services/springboard');

const Constants = require('../../utils/constants');
const Utils = require('../../utils/utils');
const logger = require('../../utils/logger');
const Style1Counter = require('../../models/style1Counter');

class SpringboardItemCreated {
	constructor () {
		this._shopify = new ShopifyService();
		this._springboard = new Springboard();
	}
	
	async handleItemCreated (data) {
		// We need to massage the custom fields
		const custom = data.custom;
		const id = data.id;
		const upc = this._generateUPCCode(data, id);
		const promises = [];
		
		if (upc === custom.upc && upc === data.public_id) {
			// Nothing to update
			logger.info({
				msg: 'SpringBoardWebHooksHandler:_handleItemCreated:: upc code did not change. Nothing to update on springboard'
			});
		} else {
			// Lets update the item now.
			custom.upc = upc;
			logger.info({
				msg: 'SpringBoardWebHooksHandler:_handleItemCreated:: need to update the upc code and public_id',
				upc
			});
			promises.push(this._updateItem(data.id, {public_id: upc, custom}));
		}
		
		promises.push(this._handleShopifyChanges(data));
		
		try {
			await Promise.all(promises);
		} catch (e) {
			logger.error({
				msg: 'SpringBoardWebHooksHandler:_handleItemCreated:: Error occurred',
				err: e.toString(),
				shopifyError: _.get(e, 'response.body.errors'),
				springBoardError: _.get(e, 'response.data.details')
				// stack: e.stack
			});
		}
	}
	
	// style1 is generated by a 2 digit code for the department + 2 digit code for the supplier + incremental digit
	// @DEPRECATED
	async _generateStyle1(item) {
		const style1 = item.custom.style1;
		const departmentName = item.custom.department;
		const supplierId = '' + item.primary_vendor_id;
		let counter;
		if (style1) {
			return style1;
		} else {
			counter = await Style1Counter.getNext();
		}
		const departmentCode = Constants.DEPARTMENT_NAME_TO_CODE[departmentName] || '';
		const newStyle1 = departmentCode.slice(0, 2) + supplierId.slice(0, 2) + counter;
		return newStyle1;
	}
	
	_generateUPCCode(item, field) {
		if (item.custom.upc) {
			return item.custom.upc;
		}
		let upc = process.env.COMPANY_GS1_CODE + (''+field);
		const checkDigit= Utils.calculateCheckDigit(upc);
		upc = upc.slice(0, 11) + checkDigit;
		return upc;
	}
	
	_updateItem(id, data) {
		return this._springboard.updateItem(id, data);
	}
	
	_fetchItemImages (itemNo) {
		return this._springboard.fetchItemImages(itemNo);
	}
	
	async _fetchItemInventory(itemNo) {
		return this._springboard.fetchItemInventory(itemNo);
	}
	
	async _handleShopifyChanges(payload) {
		const title = payload.custom.style_name;
		const style1 = payload.custom.style1;
		let product;
		const promises = [];
		try {
			if (title) {
				// First see if a product exist with the title. If not then create it. If exist then see which variant got changed.
				const products = await this._shopify.searchProduct({title, vendor: style1});
				if (!products.length) {
					// Need to create the product
					// Lets add the options too for the new product
					logger.info({
						msg: `SpringBoardWebHooksHandler:_handleShopifyChanges: Product does not exist with title: ${title}. Create new product `
					});
					
					// Check if required parameters exist in the springboard item
					
					const options = [];
					const tags = _.clone(Constants.DEFAULT_TAGS);
					this._updateOptions(null, payload, options);
					// Add the variant also
					const variants = [Utils.getProductVariantMappedData(payload, null)];
					let images = await this._fetchSpringBoardItemImages(payload);
					const inventory = await this._fetchItemInventory(payload.id);
					
					if (!this._hasAllRequiredParameter(payload, images, inventory)) {
						throw 'Springboard items does not have all the required data to create the product in shopify';
					}
					
					if (payload.custom.season) {
						tags.push(payload.custom.season);
					}
					if (payload.custom.collection) {
						tags.push(payload.custom.collection);
					}
					
					// Create the product if all the required data is available in springboard item
					product = await this._shopify.createProduct({payload, options, variants, tags});
					
					// Add images to the product with metafields and also set the image for the variant
					const variantId = product.variants.length && product.variants[0].id;
					promises.push(this._shopify.updateProductImages(product.id, images, variantId));
					logger.info({
						msg: `SpringBoardWebHooksHandler:_handleShopifyChanges: Successfully created new product with id: ${product.id} `
					});
				} else {
					product = products[0];
					logger.info({
						msg: 'SpringBoardWebHooksHandler:_handleShopifyChanges: Product already exist with title: ' + title,
						productId: product.id
					});
					// As we don't want to update the description in the shopify lets check if body_html already exist then lets not update it.
					const existingShopifyProductDescription = product.body_html;
					if (existingShopifyProductDescription) {
						payload.long_description = existingShopifyProductDescription;
					}
					// Handle the options to the existing product
					const shouldUpdate = this._updateOptions(product.id, payload, product.options);
					logger.info({
						msg: 'SpringBoardWebHooksHandler:_handleShopifyChanges: updating the product with title: ' + title,
						productId: product.id
					});
					// shouldUpdate will be true if options are needed to update. Lets do it synchronously because variant will be dependent on the options
					if (shouldUpdate) {
						await this._shopify.updateProduct(product.id, payload, product.options);
					} else {
						promises.push(this._shopify.updateProduct(product.id, payload, product.options));
					}
					
					// Fetch springboard images
					const springBoardImages = await this._fetchItemImages(payload.id);
					const springBoardImageIds = springBoardImages.map(image => image.id);
					const currentProductImages = product.images;
					// Check if any new image is added or some image is deleted
					const existingSpringBoardImagesOnShopify = [];
					const existingSpringBoardImageIdsOnShopify = [];
					const newImages = [];
					const deletedImages = [];
					let primaryImageId = null;
					
					for (let productImage of currentProductImages) {
						const imageMetadata = await this._shopify.fetchImageMetafields(productImage.id);
						const metaFieldValue = imageMetadata.length && imageMetadata[0].value;
						if (metaFieldValue) {
							const split = metaFieldValue.split('_');
							if (split[0] == payload.id) {
								existingSpringBoardImagesOnShopify.push({springBoardId: split[1], shopifyImageId: productImage.id});
								existingSpringBoardImageIdsOnShopify.push(split[1]); // this id is the springboard image id stored in image metafield
							}
						}
					}
					
					// See if some new image is added
					for (let springBoardImage of springBoardImages) {
						if (_.indexOf(existingSpringBoardImageIdsOnShopify, String(springBoardImage.id)) === -1) {
							newImages.push(Utils.buildShopifyImageData(springBoardImage));
							if (springBoardImage.primary) {
								primaryImageId = springBoardImage.id;
							}
						}
					}
					
					for (let shopifyImage of existingSpringBoardImagesOnShopify) {
						if (_.indexOf(springBoardImageIds, Number(shopifyImage.springBoardId)) === -1) {
							deletedImages.push(shopifyImage.shopifyImageId);
						}
					}
					
					// Now lets create the new images and delete the deleted images.
					for (let image of newImages) {
						promises.push(this._shopify.uploadProductImage(product.id, image));
					}
					
					for (let image of deletedImages) {
						promises.push(this._shopify.deleteProductImage(product.id, image));
					}
					
					// Add/Update the variant
					const variants = product.variants;
					let variantId = this._getExistingVariantId(payload, variants);
					if (variantId) {
						// Update the variant
						logger.info({
							msg: `SpringBoardWebHooksHandler:_handleShopifyChanges: Variant already exist in shopify for this springboard item with variantId: ${variantId}`
						});
						promises.push(this._shopify.updateProductVariant(variantId, payload, primaryImageId));
					} else {
						logger.info({
							msg: `SpringBoardWebHooksHandler:_handleShopifyChanges: Variant does not exist in shopify for this springboard item. Creating a new one`
						});
						promises.push(this._shopify.createProductVariant(product.id, payload, primaryImageId));
					}
				}
				
				await Promise.all(promises);
				
				logger.info({
					msg: '_handleShopifyChanges: successfully executed all the operations'
				});
			} else {
				logger.error({
					msg: '_handleShopifyChanges: style_name is missing in the springboard item. Product will not be created in the Shopify',
					itemId: payload.id
				});
			}
		} catch (e) {
			throw e;
		}
	}
	
	_getExistingVariantId(payload, variants) {
		const { size, color }= payload.custom;
		const upc = payload.custom.upc;
		let variantId = null;
		for (let variant of variants) {
			/*if (variant.option2 == size && variant.option1 == color) {
				variantId = variant.id;
				break;
			}*/
			if (variant.barcode == upc && variant.title != 'Default Title') {
				variantId = variant.id;
				break;
			}
		}
		return variantId;
	}
	
	_updateOptions (productId, payload, options) {
		let shouldUpdate = true;
		
		const { size, color } = payload.custom;
		
		if (!size && !color) {
			return false;
		}
		
		// If color is available then update color option
		if (color) {
			const colorIndex = _.findIndex(options, o => o.name === 'color');
			if (colorIndex > -1) {
				const colorOption = options[colorIndex];
				const colorValues = colorOption.values;
				const exist = colorValues.some(c => c == color);
				if (!exist) {
					colorOption.values.push(color);
				} else {
					shouldUpdate = false;
				}
			} else {
				options.push({
					name: 'color',
					values: [color],
					product_id: productId,
					position: 1 // Position is very important
				});
			}
		}
		
		// If size is available then update size option
		if (size) {
			const sizeIndex = _.findIndex(options, o => o.name === 'size');
			if (sizeIndex > -1) {
				const sizeOption = options[sizeIndex];
				const sizeValues = sizeOption.values;
				const exist = sizeValues.some(s => s === size);
				if (!exist) {
					sizeOption.values.push(size);
				} else {
					shouldUpdate = false;
				}
			} else {
				options.push({
					name: 'size',
					values: [size],
					product_id: productId,
					position: 2 // Position is very important
				});
			}
		}
		
		return shouldUpdate;
	}
	
	async _fetchSpringBoardItemImages(payload) {
		const images = [];
		const itemImages = await this._fetchItemImages(payload.id);
		for (let image of itemImages) {
			image = Utils.buildShopifyImageData(image);
			images.push(image);
		}
		
		return images;
	}
	
	_hasAllRequiredParameter (payload, images, inventory) {
		if (!payload.custom.style_name) {
			logger.info('style_name is not present in springboard custom data');
			return false;
		} else if (!payload.long_description) {
			logger.info('long_description is not present in springboard data');
			return false;
		} else if (!images.length) {
			logger.info('There is no image present for this springboard item. At least one image is required');
			return false;
		} else if (!(inventory && inventory.length && inventory[0].qty > 0)) {
			logger.info('Either inventory does not exist or it is  less than 1 in springboard');
			return false;
		}
		return true;
	}
}

const instance = new SpringboardItemCreated();
module.exports = instance.handleItemCreated.bind(instance);
